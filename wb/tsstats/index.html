<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Historical Stats Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .container {
            max-width: 1200px;
            margin: auto;
            padding: 20px;
        }
        #chart {
            width: 100%;
            height: 400px;
        }
        .metric-input {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .metric-input select {
            flex: 1;
            margin-right: 10px;
            padding: 5px;
        }
        .metric-input input[type="color"] {
            margin-right: 10px;
            cursor: pointer;
        }
        .error-message {
            color: red;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-2xl font-bold mb-4">Historical Stats Viewer</h1>

        <!-- UID and Name Search -->
        <div class="mb-4">
            <input id="uid-input" type="text" placeholder="Enter UID" class="border p-2 mr-2">
            <input id="name-input" type="text" placeholder="Search by name" class="border p-2 mr-2">
            <button onclick="searchByName()" class="bg-blue-500 text-white p-2 rounded">Search</button>
            <ul id="search-results" class="mt-2"></ul>
        </div>

        <!-- Time Period Toggle -->
        <div class="mb-4">
            <label class="mr-2">Time Period:</label>
            <button onclick="setTimePeriod('7d')" class="bg-blue-500 text-white p-2 mr-2 rounded">7 Days</button>
            <button onclick="setTimePeriod('30d')" class="bg-gray-200 p-2 mr-2 rounded">30 Days</button>
            <button onclick="setTimePeriod('max')" class="bg-gray-200 p-2 rounded">Max</button>
        </div>

        <!-- Metric Selection -->
        <div id="metric-inputs" class="mb-4">
            <!-- Dynamically generated metric dropdowns -->
        </div>
        <button onclick="addMetricInput()" class="bg-green-500 text-white p-2 rounded mb-4">Add Metric</button>
        <button onclick="fetchComparisonData()" class="bg-blue-500 text-white p-2 rounded">Show Stats</button>
        <p id="error-message" class="error-message">No data available for the selected UID or metrics.</p>

        <!-- Chart -->
        <svg id="chart"></svg>
    </div>

    <script>
        // Initialize global variables
        let columns = [];
        let selectedUid = '';
        let timePeriod = '7d'; // Default to 7 days

        // Supabase setup (replace placeholders with GH Secrets in your environment)
        const supabaseUrl = 'YOUR_SUPABASE_URL'; // e.g., process.env.SUPABASE_URL
        const supabaseKey = 'YOUR_SUPABASE_SERVICE_KEY'; // e.g., process.env.SUPABASE_SERVICE_KEY
        const supabase = Supabase.createClient(supabaseUrl, supabaseKey); // Fixed to use global Supabase

        // Fetch column names from wbtsdb (excluding uid and date)
        async function fetchColumns(retries = 2) {
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    const { data, error } = await supabase.rpc('get_table_columns', { table_name: 'wbtsdb' });
                    if (error) {
                        console.error(`Attempt ${attempt} - Error fetching columns:`, error);
                        if (attempt === retries) {
                            alert('Failed to load metrics after retries.');
                            return;
                        }
                        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s before retry
                        continue;
                    }
                    columns = data
                        .map(col => col.col_name)
                        .filter(col => col !== 'uid' && col !== 'date')
                        .sort();
                    console.log('Fetched columns:', columns);
                    addMetricInput(); // Add initial dropdown
                    return;
                } catch (error) {
                    console.error(`Attempt ${attempt} - fetchColumns error:`, error);
                    if (attempt === retries) {
                        alert('Error initializing metrics.');
                        return;
                    }
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }
        }

        // Add a metric dropdown
        function addMetricInput() {
            if (columns.length === 0) {
                alert('Metrics not yet loaded. Please wait.');
                return;
            }
            if (document.querySelectorAll('.metric-input').length >= 10) {
                alert('Maximum 10 metrics allowed.');
                return;
            }
            const div = document.createElement('div');
            div.className = 'metric-input flex items-center';

            const select = document.createElement('select');
            select.innerHTML = '<option value="">Select Metric</option>' + 
                columns.map(col => `<option value="${col}">${col}</option>`).join('');
            select.className = 'border p-2';

            const colorPicker = document.createElement('input');
            colorPicker.type = 'color';
            colorPicker.value = generateRandomColor();
            colorPicker.className = 'cursor-pointer';

            const removeButton = document.createElement('button');
            removeButton.textContent = 'Remove';
            removeButton.className = 'bg-red-500 text-white p-2 rounded';
            removeButton.onclick = () => div.remove();

            div.appendChild(select);
            div.appendChild(colorPicker);
            div.appendChild(removeButton);
            document.getElementById('metric-inputs').appendChild(div);
        }

        // Generate random color
        function generateRandomColor() {
            return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
        }

        // Search by name
        async function searchByName() {
            const query = document.getElementById('name-input').value.trim();
            if (!query) return alert('Please enter a name to search.');
            try {
                const response = await axios.get(`https://wbapi.wbpjs.com/players/searchByName?query=${encodeURIComponent(query)}`);
                const results = response.data;
                const ul = document.getElementById('search-results');
                ul.innerHTML = '';
                if (results.length === 0) {
                    ul.innerHTML = '<li>No players found.</li>';
                    return;
                }
                results.forEach(player => {
                    const li = document.createElement('li');
                    li.textContent = `${player.nick} (UID: ${player.uid})`;
                    li.className = 'cursor-pointer hover:bg-gray-100 p-1';
                    li.onclick = () => {
                        document.getElementById('uid-input').value = player.uid;
                        selectedUid = player.uid;
                        ul.innerHTML = '';
                    };
                    ul.appendChild(li);
                });
            } catch (error) {
                console.error('Error searching by name:', error);
                alert('Failed to search players.');
            }
        }

        // Set time period
        function setTimePeriod(period) {
            timePeriod = period;
            document.querySelectorAll('.mb-4 button').forEach(btn => {
                btn.className = btn.textContent.includes(period.toUpperCase()) ? 
                    'bg-blue-500 text-white p-2 mr-2 rounded' : 
                    'bg-gray-200 p-2 mr-2 rounded';
            });
            fetchComparisonData();
        }

        // Fetch and update chart data
        async function fetchComparisonData() {
            const uidInput = document.getElementById('uid-input').value.trim();
            if (!uidInput && !selectedUid) {
                alert('Please enter a UID or select one from search results.');
                return;
            }
            selectedUid = uidInput || selectedUid;

            const metrics = Array.from(document.querySelectorAll('.metric-input select'))
                .map(select => ({
                    column: select.value,
                    color: select.nextElementSibling.value
                }))
                .filter(metric => metric.column);

            if (metrics.length === 0) {
                alert('Please select at least one metric.');
                return;
            }

            // Calculate date range
            const now = new Date();
            let startDate;
            if (timePeriod === '7d') {
                startDate = new Date(now.setDate(now.getDate() - 7)).toISOString().split('T')[0];
            } else if (timePeriod === '30d') {
                startDate = new Date(now.setDate(now.getDate() - 30)).toISOString().split('T')[0];
            } else {
                startDate = '2000-01-01'; // Arbitrary early date for 'max'
            }

            // Fetch data from Supabase
            try {
                const { data, error } = await supabase
                    .from('wbtsdb')
                    .select(`date, ${metrics.map(m => m.column).join(', ')}`)
                    .eq('uid', selectedUid)
                    .gte('date', startDate)
                    .order('date', { ascending: true });

                if (error || !data || data.length === 0) {
                    document.getElementById('error-message').style.display = 'block';
                    console.error('Error fetching data:', error);
                    return;
                }

                document.getElementById('error-message').style.display = 'none';
                updateChart(data, metrics);
            } catch (error) {
                console.error('fetchComparisonData error:', error);
                alert('Failed to load data.');
            }
        }

        // Update D3 chart
        function updateChart(data, metrics) {
            // Clear existing chart
            d3.select('#chart').selectAll('*').remove();

            // Set up dimensions
            const margin = { top: 20, right: 80, bottom: 50, left: 50 };
            const width = 1200 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            // Create SVG
            const svg = d3.select('#chart')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Parse dates and prepare data
            const parseDate = d3.timeParse('%Y-%m-%d');
            data.forEach(d => {
                d.date = parseDate(d.date);
            });

            // Set scales
            const x = d3.scaleTime()
                .domain(d3.extent(data, d => d.date))
                .range([0, width]);

            const yValues = metrics.flatMap(metric => 
                data.map(d => d[metric.column]).filter(v => v !== null)
            );
            const y = d3.scaleLinear()
                .domain([0, d3.max(yValues) * 1.1 || 1])
                .range([height, 0])
                .nice();

            // Define line generator
            const line = d3.line()
                .x(d => x(d.date))
                .y(d => y(d[metric]))
                .defined(d => d[metric] !== null);

            // Draw lines
            metrics.forEach(metric => {
                svg.append('path')
                    .datum(data)
                    .attr('fill', 'none')
                    .attr('stroke', metric.color)
                    .attr('stroke-width', 2)
                    .attr('d', line.x(d => x(d.date)).y(d => y(d[metric.column])));
            });

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');

            svg.append('g')
                .call(d3.axisLeft(y))
                .append('text')
                .attr('fill', '#000')
                .attr('transform', 'rotate(-90)')
                .attr('y', -40)
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .text('Value');

            // Add legend
            const legend = svg.append('g')
                .attr('transform', `translate(${width - 70}, 0)`);
            metrics.forEach((metric, i) => {
                legend.append('rect')
                    .attr('x', 0)
                    .attr('y', i * 20)
                    .attr('width', 15)
                    .attr('height', 15)
                    .attr('fill', metric.color);
                legend.append('text')
                    .attr('x', 20)
                    .attr('y', i * 20 + 12)
                    .text(metric.column)
                    .style('font-size', '12px');
            });
        }

        // Initialize
        fetchColumns();
    </script>
</body>
</html>
