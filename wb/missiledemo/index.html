<!DOCTYPE html>
<html>
<head>
    <title>Missile Guidance Demo</title>
    <style>
        body { margin: 0; display: flex; font-family: Arial, sans-serif; }
        #controls { padding: 20px; }
        canvas { border: 1px solid black; }
        .slider-container { margin: 10px 0; }
        button { padding: 5px 10px; margin: 5px 0; }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="controls">
        <div class="slider-container">
            <label>Missile Frequency (s): <span id="freqVal">5</span></label>
            <input type="range" id="missileFreq" min="1" max="10" value="5">
        </div>
        <div class="slider-container">
            <label>Missile Speed: <span id="missileSpeedVal">200</span></label>
            <input type="range" id="missileSpeed" min="100" max="500" value="200">
        </div>
        <div class="slider-container">
            <label>Jet Speed: <span id="jetSpeedVal">150</span></label>
            <input type="range" id="jetSpeed" min="50" max="300" value="150">
        </div>
        <div class="slider-container">
            <label>Flare Frequency (s): <span id="flareFreqVal">0.5</span></label>
            <input type="range" id="flareFreq" min="0.1" max="2" step="0.1" value="0.5">
        </div>
        <div class="slider-container">
            <label>Fool Rate (%): <span id="foolRateVal">50</span></label>
            <input type="range" id="foolRate" min="5" max="100" value="50">
        </div>
        <button id="toggleBtn">Start</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const toggleBtn = document.getElementById('toggleBtn');
        const controls = {
            missileFreq: document.getElementById('missileFreq'),
            missileSpeed: document.getElementById('missileSpeed'),
            jetSpeed: document.getElementById('jetSpeed'),
            flareFreq: document.getElementById('flareFreq'),
            foolRate: document.getElementById('foolRate')
        };

        // Display initial slider values
        document.getElementById('freqVal').textContent = controls.missileFreq.value;
        document.getElementById('missileSpeedVal').textContent = controls.missileSpeed.value;
        document.getElementById('jetSpeedVal').textContent = controls.jetSpeed.value;
        document.getElementById('flareFreqVal').textContent = controls.flareFreq.value;
        document.getElementById('foolRateVal').textContent = controls.foolRate.value;

        // Game objects
        const launcher = { x: canvas.width/2, y: canvas.height - 20 };
        let jet = { x: canvas.width/2, y: canvas.height/2, speed: 150, radius: 5 };
        let missiles = [];
        let flares = [];
        let explosions = [];
        let lastMissileTime = 0;
        let lastFlareTime = 0;
        let isRunning = false;
        let mouseX = canvas.width/2;
        let mouseY = canvas.height/2;

        // Update slider displays
        controls.missileFreq.oninput = () => document.getElementById('freqVal').textContent = controls.missileFreq.value;
        controls.missileSpeed.oninput = () => document.getElementById('missileSpeedVal').textContent = controls.missileSpeed.value;
        controls.jetSpeed.oninput = () => {
            document.getElementById('jetSpeedVal').textContent = controls.jetSpeed.value;
            jet.speed = parseInt(controls.jetSpeed.value);
        };
        controls.flareFreq.oninput = () => document.getElementById('flareFreqVal').textContent = controls.flareFreq.value;
        controls.foolRate.oninput = () => document.getElementById('foolRateVal').textContent = controls.foolRate.value;

        // Mouse movement
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        // Start/Pause button
        toggleBtn.addEventListener('click', () => {
            isRunning = !isRunning;
            toggleBtn.textContent = isRunning ? 'Pause' : 'Start';
            if (isRunning) animate();
        });

        // Flare deployment
        document.addEventListener('keydown', (e) => {
            if (e.key === 'q' || e.key === 'Q') {
                const currentTime = performance.now();
                if (currentTime - lastFlareTime > controls.flareFreq.value * 1000) {
                    flares.push(new Flare(jet.x - 10, jet.y));
                    flares.push(new Flare(jet.x + 10, jet.y));
                    lastFlareTime = currentTime;
                }
            }
        });

        class Missile {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.speed = parseInt(controls.missileSpeed.value);
                this.width = 4;
                this.height = 12;
                this.distanceTraveled = 0;
                this.angle = 0;
                this.target = jet;
                this.isFooled = Math.random() * 100 < parseInt(controls.foolRate.value) && flares.length > 0;
                if (this.isFooled) {
                    this.target = flares[Math.floor(Math.random() * flares.length)];
                }
            }

            update(dt) {
                const targetX = this.target.x;
                const targetY = this.target.y;
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const velocityX = (dx / distance) * this.speed * dt;
                    const velocityY = (dy / distance) * this.speed * dt;
                    this.x += velocityX;
                    this.y += velocityY;
                    this.distanceTraveled += Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                    this.angle = Math.atan2(dy, dx);
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI/2);
                ctx.fillStyle = 'red';
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                ctx.restore();
            }
        }

        class Flare {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.speedX = (x < jet.x ? -50 : 50);
                this.speedY = 100;
                this.radius = 3;
                this.lifespan = 1;
                this.creationTime = performance.now();
            }

            update(dt) {
                this.x += this.speedX * dt;
                this.y += this.speedY * dt;
                this.lifespan -= dt;
            }

            draw() {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.lifespan = 0.3; // 300ms
                this.creationTime = performance.now();
            }

            update(dt) {
                this.lifespan -= dt;
            }

            draw() {
                ctx.fillStyle = 'orange';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function checkCollisions() {
            missiles.forEach((missile, mIndex) => {
                // Check jet collision
                const jetDist = Math.sqrt((missile.x - jet.x) ** 2 + (missile.y - jet.y) ** 2);
                if (jetDist < jet.radius + missile.height/2) {
                    explosions.push(new Explosion(missile.x, missile.y));
                    missiles.splice(mIndex, 1);
                    return;
                }

                // Check flare collisions
                flares.forEach((flare, fIndex) => {
                    const flareDist = Math.sqrt((missile.x - flare.x) ** 2 + (missile.y - flare.y) ** 2);
                    if (flareDist < flare.radius + missile.height/2) {
                        explosions.push(new Explosion(missile.x, missile.y));
                        missiles.splice(mIndex, 1);
                        flares.splice(fIndex, 1);
                        return;
                    }
                });
            });
        }

        function drawScene() {
            // Dark gray background
            ctx.fillStyle = '#666666';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw launcher
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.moveTo(launcher.x - 15, launcher.y);
            ctx.lineTo(launcher.x + 15, launcher.y);
            ctx.lineTo(launcher.x, launcher.y - 20);
            ctx.fill();

            // Draw jet
            ctx.fillStyle = 'green';
            ctx.beginPath();
            ctx.arc(jet.x, jet.y, jet.radius, 0, Math.PI * 2);
            ctx.fill();

            // Draw missiles
            missiles.forEach(missile => missile.draw());

            // Draw flares
            flares.forEach(flare => flare.draw());

            // Draw explosions
            explosions.forEach(explosion => explosion.draw());
        }

        function update(dt) {
            // Jet movement
            const dx = mouseX - jet.x;
            const dy = mouseY - jet.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 5) {
                const velocityX = (dx / distance) * jet.speed * dt;
                const velocityY = (dy / distance) * jet.speed * dt;
                jet.x += velocityX;
                jet.y += velocityY;
            }

            // Missile launch
            const currentTime = performance.now();
            if (currentTime - lastMissileTime > controls.missileFreq.value * 1000) {
                missiles.push(new Missile(launcher.x, launcher.y));
                lastMissileTime = currentTime;
            }

            // Update missiles
            missiles = missiles.filter(m => 
                m.y > 0 && 
                m.y < canvas.height && 
                m.x > 0 && 
                m.x < canvas.width && 
                m.distanceTraveled < 600
            );
            missiles.forEach(missile => missile.update(dt));

            // Update flares
            flares = flares.filter(f => f.lifespan > 0);
            flares.forEach(flare => flare.update(dt));

            // Update explosions
            explosions = explosions.filter(e => e.lifespan > 0);
            explosions.forEach(explosion => explosion.update(dt));

            // Check collisions
            checkCollisions();
        }

        let lastTime = 0;
        function animate(timestamp = 0) {
            if (!isRunning) return;

            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            update(dt);
            drawScene();
            requestAnimationFrame(animate);
        }

        // Initial draw
        drawScene();
    </script>
</body>
</html>
